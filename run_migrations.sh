#!/bin/bash

# Supabase credentials from .env
SUPABASE_URL="https://qsvjvgsnbslgypykuznd.supabase.co"
SERVICE_ROLE_KEY="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFzdmp2Z3NuYnNsZ3lweWt1em5kIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1OTkwMDUwOCwiZXhwIjoyMDc1NDc2NTA4fQ.rcq2isspQ7gtpYRpIcYrtwtCb3VJ_JgkjibWlMJfwsk"

echo "ðŸ”§ Running Analytics RLS Fix..."

# Run the Analytics RLS Fix
curl -X POST "${SUPABASE_URL}/rest/v1/rpc/" \
  -H "apikey: ${SERVICE_ROLE_KEY}" \
  -H "Authorization: Bearer ${SERVICE_ROLE_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "execute_sql",
    "args": {
      "sql": "-- Enable RLS on user_sessions if not already enabled\nALTER TABLE user_sessions ENABLE ROW LEVEL SECURITY;\n\n-- Drop existing policies if they exist\nDROP POLICY IF EXISTS \"Users can view their own sessions\" ON user_sessions;\nDROP POLICY IF EXISTS \"Service role can manage all sessions\" ON user_sessions;\n\n-- Allow users to view their own sessions\nCREATE POLICY \"Users can view their own sessions\"\nON user_sessions\nFOR SELECT\nTO authenticated\nUSING (auth.uid() = user_id);\n\n-- Allow service role (backend) to manage all sessions\nCREATE POLICY \"Service role can manage all sessions\"\nON user_sessions\nFOR ALL\nTO service_role\nUSING (true)\nWITH CHECK (true);\n\n-- Grant necessary permissions\nGRANT SELECT ON user_sessions TO authenticated;\nGRANT ALL ON user_sessions TO service_role;"
    }
  }' && echo "âœ… Analytics RLS fix completed!"

echo ""
echo "ðŸ”” Running Notification System Migration..."

# Run the complete notification system migration
curl -X POST "${SUPABASE_URL}/rest/v1/rpc/" \
  -H "apikey: ${SERVICE_ROLE_KEY}" \
  -H "Authorization: Bearer ${SERVICE_ROLE_KEY}" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "execute_sql", 
    "args": {
      "sql": "-- In-App Notifications Migration\n\n-- CREATE NOTIFICATIONS TABLE\nCREATE TABLE IF NOT EXISTS notifications (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  title TEXT NOT NULL,\n  body TEXT NOT NULL,\n  notification_type VARCHAR(50) NOT NULL DEFAULT \"general\",\n  image_url TEXT,\n  data JSONB,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Enable RLS on notifications\nALTER TABLE notifications ENABLE ROW LEVEL SECURITY;\n\n-- Users can view all notifications\nCREATE POLICY \"Users can view all notifications\"\nON notifications\nFOR SELECT\nTO authenticated\nUSING (true);\n\n-- Service role can manage notifications\nCREATE POLICY \"Service role can manage notifications\"\nON notifications\nFOR ALL\nTO service_role\nUSING (true)\nWITH CHECK (true);\n\n-- CREATE USER_NOTIFICATION_READS TABLE\nCREATE TABLE IF NOT EXISTS user_notification_reads (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\n  notification_id UUID NOT NULL REFERENCES notifications(id) ON DELETE CASCADE,\n  read_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  UNIQUE(user_id, notification_id)\n);\n\n-- Create index for fast lookups\nCREATE INDEX IF NOT EXISTS idx_user_notification_reads_user_id ON user_notification_reads(user_id);\nCREATE INDEX IF NOT EXISTS idx_user_notification_reads_notification_id ON user_notification_reads(notification_id);\n\n-- Enable RLS\nALTER TABLE user_notification_reads ENABLE ROW LEVEL SECURITY;\n\n-- Users can view their own read notifications\nCREATE POLICY \"Users can view their own read notifications\"\nON user_notification_reads\nFOR SELECT\nTO authenticated\nUSING (auth.uid() = user_id);\n\n-- Users can mark notifications as read\nCREATE POLICY \"Users can mark notifications as read\"\nON user_notification_reads\nFOR INSERT\nTO authenticated\nWITH CHECK (auth.uid() = user_id);\n\n-- Users can delete their own read records\nCREATE POLICY \"Users can delete their own read records\"\nON user_notification_reads\nFOR DELETE\nTO authenticated\nUSING (auth.uid() = user_id);\n\n-- CREATE NOTIFICATION_PREFERENCES TABLE\nCREATE TABLE IF NOT EXISTS notification_preferences (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,\n  push_enabled BOOLEAN DEFAULT true,\n  email_enabled BOOLEAN DEFAULT true,\n  in_app_enabled BOOLEAN DEFAULT true,\n  subscription_expiring_enabled BOOLEAN DEFAULT true,\n  content_approved_enabled BOOLEAN DEFAULT true,\n  welcome_enabled BOOLEAN DEFAULT true,\n  milestones_enabled BOOLEAN DEFAULT true,\n  marketing_enabled BOOLEAN DEFAULT false,\n  quiet_hours JSONB DEFAULT NULL,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()\n);\n\n-- Enable RLS\nALTER TABLE notification_preferences ENABLE ROW LEVEL SECURITY;\n\n-- Users can view their own preferences\nCREATE POLICY \"Users can view their own preferences\"\nON notification_preferences\nFOR SELECT\nTO authenticated\nUSING (auth.uid() = user_id);\n\n-- Users can update their own preferences\nCREATE POLICY \"Users can update their own preferences\"\nON notification_preferences\nFOR UPDATE\nTO authenticated\nUSING (auth.uid() = user_id)\nWITH CHECK (auth.uid() = user_id);\n\n-- Service role can manage all preferences\nCREATE POLICY \"Service role can manage all preferences\"\nON notification_preferences\nFOR ALL\nTO service_role\nUSING (true)\nWITH CHECK (true);\n\n-- CREATE HELPER FUNCTION\nCREATE OR REPLACE FUNCTION get_user_notifications_with_read_status(\n  user_id_param UUID,\n  limit_param INT DEFAULT 50,\n  offset_param INT DEFAULT 0\n)\nRETURNS TABLE (\n  id UUID,\n  title TEXT,\n  body TEXT,\n  notification_type VARCHAR,\n  image_url TEXT,\n  data JSONB,\n  created_at TIMESTAMP WITH TIME ZONE,\n  is_read BOOLEAN,\n  read_at TIMESTAMP WITH TIME ZONE\n) AS $$\nBEGIN\n  RETURN QUERY\n  SELECT \n    n.id,\n    n.title,\n    n.body,\n    n.notification_type,\n    n.image_url,\n    n.data,\n    n.created_at,\n    (unr.id IS NOT NULL) AS is_read,\n    unr.read_at\n  FROM notifications n\n  LEFT JOIN user_notification_reads unr \n  ON n.id = unr.notification_id AND unr.user_id = user_id_param\n  ORDER BY n.created_at DESC\n  LIMIT limit_param\n  OFFSET offset_param;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Function to get unread notification count\nCREATE OR REPLACE FUNCTION get_unread_notification_count(\n  user_id_param UUID\n)\nRETURNS INT AS $$\nDECLARE\n  unread_count INT;\nBEGIN\n  SELECT COUNT(*)::INT INTO unread_count\n  FROM notifications n\n  WHERE NOT EXISTS (\n    SELECT 1 FROM user_notification_reads unr\n    WHERE unr.notification_id = n.id AND unr.user_id = user_id_param\n  );\n  \n  RETURN unread_count;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- CREATE TRIGGER FOR DEFAULT PREFERENCES\nCREATE OR REPLACE FUNCTION create_notification_preferences_for_new_user()\nRETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO notification_preferences (user_id)\n  VALUES (NEW.id)\n  ON CONFLICT (user_id) DO NOTHING;\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\nDROP TRIGGER IF EXISTS on_auth_user_created_notification_prefs ON auth.users;\n\nCREATE TRIGGER on_auth_user_created_notification_prefs\n  AFTER INSERT ON auth.users\n  FOR EACH ROW\n  EXECUTE FUNCTION create_notification_preferences_for_new_user();\n\n-- GRANT PERMISSIONS\nGRANT SELECT ON notifications TO authenticated;\nGRANT SELECT, INSERT, DELETE ON user_notification_reads TO authenticated;\nGRANT SELECT, UPDATE ON notification_preferences TO authenticated;\n\nGRANT ALL ON notifications TO service_role;\nGRANT ALL ON user_notification_reads TO service_role;\nGRANT ALL ON notification_preferences TO service_role;\n\n-- Grant execute on functions\nGRANT EXECUTE ON FUNCTION get_user_notifications_with_read_status TO authenticated;\nGRANT EXECUTE ON FUNCTION get_unread_notification_count TO authenticated;"
    }
  }' && echo "âœ… Notification system migration completed!"

echo ""
echo "ðŸŽ‰ All migrations completed successfully!"
echo "ðŸ“± Now refresh your Jeeva Learning App to see all errors resolved!"